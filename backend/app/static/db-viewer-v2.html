<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Database Viewer V2 - Game Platform</title>
    <!-- THIS IS V2 - If you see the old design, clear cache! -->
    <link rel="stylesheet" href="/static/css/db-viewer.css">
</head>
<body>
    <div class="container">
        <!-- Header Section -->
        <div class="header">
            <h1>üéÆ Database Viewer</h1>
            <p class="subtitle">Sistema di gestione e visualizzazione database</p>
            <button onclick="logout()" style="position: absolute; top: 20px; right: 20px; padding: 8px 16px; background: #ff3d71; border: none; border-radius: 6px; color: white; cursor: pointer; font-weight: 600;">Logout</button>
        </div>
        
        <!-- Stats Cards - Generated dynamically -->
        <div class="stats" id="statsContainer"></div>
        
        <!-- Tabs - Generated dynamically -->
        <div class="tabs" id="tabsContainer"></div>
        
        <!-- Controls -->
        <div class="controls">
            <div class="search-box advanced-search">
                <input type="text" id="searchInput" placeholder="üîç Cerca... (es: username:mario, xp>100, is_active:true)">
                <button class="search-help-btn" onclick="toggleQueryHelp()" title="Guida sintassi">?</button>
                <button class="query-builder-btn" onclick="toggleQueryBuilder()" title="Query Builder">‚öôÔ∏è</button>
            </div>
            <button id="createBtn" onclick="handleCreate()">+ New</button>
            <button onclick="refreshData()">Refresh</button>
            <button id="openSessionsBtn" onclick="showOpenSessions()" style="background: #e67700; border-color: #e67700; display: none;">Open Sessions</button>
            <button onclick="exportJSON()">Export JSON</button>
            <button onclick="exportCSV()">Export CSV</button>
        </div>
        
        <!-- Active Filters -->
        <div id="activeFilters" class="active-filters" style="display: none;">
            <span class="filters-label">Filtri attivi:</span>
            <div id="filterChips" class="filter-chips"></div>
            <span id="sortChip" class="sort-chip" style="display: none;"></span>
            <span id="filterCount" class="filter-count"></span>
            <button class="clear-filters-btn" onclick="clearAllFilters()" id="clearAllBtn" style="display: none;">‚úï Cancella tutti</button>
        </div>
        
        <!-- Query Builder Panel -->
        <div id="queryBuilderPanel" class="query-builder-panel" style="display: none;">
            <div class="query-builder-header">
                <h4>üîß Query Builder</h4>
                <button onclick="toggleQueryBuilder()" class="close-btn">‚úï</button>
            </div>
            <div class="query-builder-body">
                <!-- Filter Section -->
                <div class="query-section">
                    <div class="query-section-title">üîç Filtri</div>
                    <div class="filter-row" id="filterRowTemplate">
                        <select id="filterField" class="filter-select" onchange="updateOperatorOptions()">
                            <option value="">-- Seleziona campo --</option>
                        </select>
                        <select id="filterOperator" class="filter-select">
                            <option value="contains">contiene</option>
                            <option value="equals">uguale a</option>
                            <option value="not_equals">diverso da</option>
                            <option value="starts">inizia con</option>
                            <option value="ends">finisce con</option>
                            <option value="gt">maggiore di</option>
                            <option value="gte">maggiore o uguale</option>
                            <option value="lt">minore di</option>
                            <option value="lte">minore o uguale</option>
                        </select>
                        <input type="text" id="filterValue" class="filter-input" placeholder="Valore...">
                        <div id="filterButtons" class="filter-buttons">
                            <!-- Buttons will be dynamically generated -->
                        </div>
                    </div>
                </div>
                
                <!-- Sort Section -->
                <div class="query-section">
                    <div class="query-section-title">‚ÜïÔ∏è Ordinamento</div>
                    <div class="sort-row">
                        <select id="sortField" class="filter-select">
                            <option value="">-- Nessun ordinamento --</option>
                        </select>
                        <select id="sortDirection" class="filter-select sort-direction">
                            <option value="asc">‚Üë Crescente (A-Z, 0-9)</option>
                            <option value="desc">‚Üì Decrescente (Z-A, 9-0)</option>
                        </select>
                        <button class="apply-sort-btn" onclick="applySortFromBuilder()">Ordina</button>
                        <button class="clear-sort-btn" onclick="clearSort()">‚úï</button>
                    </div>
                    <div id="currentSortInfo" class="current-sort-info" style="display: none;"></div>
                </div>
            </div>
        </div>
        
        <!-- Query Help Tooltip -->
        <div id="queryHelpPanel" class="query-help-panel" style="display: none;">
            <div class="query-help-header">
                <h4>üìñ Sintassi Query</h4>
                <button onclick="toggleQueryHelp()" class="close-btn">‚úï</button>
            </div>
            <div class="query-help-body">
                <table class="help-table">
                    <tr><th>Sintassi</th><th>Descrizione</th><th>Esempio</th></tr>
                    <tr><td><code>testo</code></td><td>Cerca in tutti i campi</td><td><code>mario</code></td></tr>
                    <tr><td><code>campo:valore</code></td><td>Cerca nel campo specifico</td><td><code>username:mario</code></td></tr>
                    <tr><td><code>campo=valore</code></td><td>Valore esatto</td><td><code>status=active</code></td></tr>
                    <tr><td><code>campo!=valore</code></td><td>Diverso da</td><td><code>status!=disabled</code></td></tr>
                    <tr><td><code>campo>valore</code></td><td>Maggiore di</td><td><code>xp>100</code></td></tr>
                    <tr><td><code>campo>=valore</code></td><td>Maggiore o uguale</td><td><code>score>=500</code></td></tr>
                    <tr><td><code>campo<valore</code></td><td>Minore di</td><td><code>level<10</code></td></tr>
                    <tr><td><code>campo<=valore</code></td><td>Minore o uguale</td><td><code>coins<=1000</code></td></tr>
                    <tr><td><code>campo:true/false</code></td><td>Boolean</td><td><code>is_active:true</code></td></tr>
                    <tr><td><code>filtro1 filtro2</code></td><td>Combina filtri (AND)</td><td><code>xp>100 is_active:true</code></td></tr>
                    <tr><td><code>filtro1 | filtro2</code></td><td>Alternativa (OR)</td><td><code>game_id:1 | game_id:2</code></td></tr>
                    <tr><td><code>filtro1 OR filtro2</code></td><td>Alternativa (OR)</td><td><code>username:mario OR username:luigi</code></td></tr>
                </table>
                <h5 style="margin: 15px 0 8px 0; color: #525252;">‚ÜïÔ∏è Ordinamento</h5>
                <table class="help-table">
                    <tr><th>Sintassi</th><th>Descrizione</th><th>Esempio</th></tr>
                    <tr><td><code>sort:campo</code></td><td>Ordina crescente (A-Z)</td><td><code>sort:score</code></td></tr>
                    <tr><td><code>sort:-campo</code></td><td>Ordina decrescente (Z-A)</td><td><code>sort:-score</code></td></tr>
                    <tr><td><code>sort:campo:desc</code></td><td>Ordina decrescente</td><td><code>sort:created_at:desc</code></td></tr>
                    <tr><td><code>sort:campo:asc</code></td><td>Ordina crescente</td><td><code>sort:username:asc</code></td></tr>
                </table>
                <p style="margin-top: 10px; font-size: 0.813rem; color: #737373;">üí° Combina filtri e ordinamento: <code>score>100 sort:-xp_earned</code></p>
            </div>
        </div>
        
        <!-- Table Container -->
        <div class="table-container">
            <div id="loading" class="loading">
                <div class="loading-spinner"></div>
                <div>Caricamento dati in corso...</div>
            </div>
            
            <!-- Dynamic Table Containers -->
            <div id="tablesContainer"></div>
            
            <!-- ER Diagram Container -->
            <div id="er-diagramContainer" class="tab-content">
                <div class="er-controls">
                    <button onclick="resetERDiagram()" style="margin-right: 10px;">üîÑ Reset View</button>
                    <button onclick="zoomIn()" style="margin-right: 5px;">üîç+ Zoom In</button>
                    <button onclick="zoomOut()" style="margin-right: 10px;">üîç- Zoom Out</button>
                    <label style="display: inline-block; margin-left: 10px;">
                        <input type="checkbox" id="showFieldTypes" checked onchange="updateERDiagram()"> Mostra tipi campi
                    </label>
                </div>
                <div id="erDiagramCanvas" style="width: 100%; height: 700px; border: 1px solid #ddd; background: #fafafa; position: relative; overflow: hidden; cursor: grab;">
                    <svg id="erSvg" style="width: 100%; height: 100%;"></svg>
                </div>
            </div>
            
            <!-- Empty State -->
            <div id="emptyState" class="empty" style="display: none;"></div>
        </div>
    </div>
    
    <!-- Detail Modal -->
    <div id="detailModal" class="modal">
        <div class="modal-content"></div>
    </div>

    <!-- CRUD Modal -->
    <div id="crudModal" class="modal">
        <div class="modal-content"></div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Scripts -->
    <script src="/static/js/db-schema.js"></script>
    <script src="/static/js/db-viewer-templates-v2.js"></script>
    <script src="/static/js/db-viewer-crud-v2.js"></script>
    <script>
        // ============ CONFIGURATION ============
        const CONFIG = {
            API_BASE: '/admin',
            ITEMS_PER_PAGE: 20
        };

        // ============ APPLICATION STATE ============
        const AppState = {
            currentTab: 'games',
            data: {},
            originalData: {},
            searchTerm: '',
            isLoading: false,
            currentPage: 1,
            itemsPerPage: 20,
            totalPages: 1,
            filters: [],  // Array of {field, operator, value, display}
            queryBuilderOpen: false,
            queryHelpOpen: false,
            sortColumn: null,
            sortDirection: 'asc'  // 'asc' or 'desc'
        };
        
        // ============ QUERY SYSTEM ============
        const QueryEngine = {
            // Operators mapping
            operators: {
                ':': 'contains',
                '=': 'equals',
                '!=': 'not_equals',
                '>=': 'gte',
                '<=': 'lte',
                '>': 'gt',
                '<': 'lt'
            },
            
            operatorLabels: {
                'contains': 'contiene',
                'equals': '=',
                'not_equals': '‚â†',
                'starts': 'inizia con',
                'ends': 'finisce con',
                'gt': '>',
                'gte': '‚â•',
                'lt': '<',
                'lte': '‚â§'
            },
            
            // Parse query string into filters with OR support
            // Syntax: "filter1 filter2" = AND, "filter1 | filter2" or "filter1 OR filter2" = OR
            // Sort syntax: "sort:campo" = ASC, "sort:campo:desc" or "sort:-campo" = DESC
            parseQuery(queryString) {
                // Extract sort directive first
                const sortMatch = queryString.match(/\bsort:(-?)(\w+)(?::(asc|desc))?/i);
                if (sortMatch) {
                    const isDesc = sortMatch[1] === '-' || (sortMatch[3] && sortMatch[3].toLowerCase() === 'desc');
                    AppState.sortColumn = sortMatch[2];
                    AppState.sortDirection = isDesc ? 'desc' : 'asc';
                    // Remove sort directive from query
                    queryString = queryString.replace(/\bsort:(-?)(\w+)(?::(asc|desc))?/i, '').trim();
                    updateCurrentSortInfo();
                    updateSortIcons();
                } else if (!queryString.includes('sort:')) {
                    // No sort in query - clear sort only if user is typing (not programmatic update)
                    // We don't auto-clear to preserve sort when just filtering
                }
                
                if (!queryString.trim()) return [];
                
                // Split by OR operator (| or OR)
                const orGroups = queryString.split(/\s+(?:\||OR)\s+/i);
                
                const filterGroups = orGroups.map(group => {
                    const filters = [];
                    // Regex to match field:value, field=value, field>value, etc.
                    const regex = /(\w+)(!=|>=|<=|[:=><])([^\s]+)|([^\s]+)/g;
                    let match;
                    
                    while ((match = regex.exec(group)) !== null) {
                        if (match[1] && match[2] && match[3]) {
                            const field = match[1];
                            const op = this.operators[match[2]] || 'contains';
                            let value = match[3];
                            
                            if (value.startsWith('"') && value.endsWith('"')) {
                                value = value.slice(1, -1);
                            }
                            
                            filters.push({
                                field: field,
                                operator: op,
                                value: value,
                                display: `${field} ${this.operatorLabels[op]} ${value}`
                            });
                        } else if (match[4]) {
                            filters.push({
                                field: '*',
                                operator: 'contains',
                                value: match[4],
                                display: `"${match[4]}" in tutti i campi`
                            });
                        }
                    }
                    return filters;
                }).filter(g => g.length > 0);
                
                // Flatten with OR markers
                const result = [];
                filterGroups.forEach((group, idx) => {
                    if (idx > 0) {
                        result.push({ isOrSeparator: true, display: 'OR' });
                    }
                    result.push(...group);
                });
                
                return result;
            },
            
            // Apply filters to items (supports OR groups)
            applyFilters(items, filters) {
                if (!filters.length) return items;
                
                // Split filters into OR groups
                const orGroups = [];
                let currentGroup = [];
                
                filters.forEach(filter => {
                    if (filter.isOrSeparator) {
                        if (currentGroup.length) {
                            orGroups.push(currentGroup);
                            currentGroup = [];
                        }
                    } else {
                        currentGroup.push(filter);
                    }
                });
                if (currentGroup.length) {
                    orGroups.push(currentGroup);
                }
                
                // If only one group, use AND logic
                if (orGroups.length <= 1) {
                    const group = orGroups[0] || [];
                    return items.filter(item => 
                        group.every(filter => this.matchFilter(item, filter))
                    );
                }
                
                // Multiple groups: OR between groups, AND within each group
                return items.filter(item => 
                    orGroups.some(group => 
                        group.every(filter => this.matchFilter(item, filter))
                    )
                );
            },
            
            // Check if item matches a single filter
            matchFilter(item, filter) {
                const { field, operator, value } = filter;
                
                // Global search (all fields)
                if (field === '*') {
                    return Object.values(item).some(val => 
                        val !== null && val !== undefined && 
                        String(val).toLowerCase().includes(value.toLowerCase())
                    );
                }
                
                // Specific field search
                const itemValue = item[field];
                if (itemValue === null || itemValue === undefined) {
                    return operator === 'not_equals';
                }
                
                const strValue = String(itemValue).toLowerCase();
                const searchValue = value.toLowerCase();
                
                switch (operator) {
                    case 'contains':
                        return strValue.includes(searchValue);
                    case 'equals':
                        // Handle booleans
                        if (typeof itemValue === 'boolean') {
                            return itemValue === (searchValue === 'true' || searchValue === '1' || searchValue === 'yes');
                        }
                        return strValue === searchValue;
                    case 'not_equals':
                        if (typeof itemValue === 'boolean') {
                            return itemValue !== (searchValue === 'true' || searchValue === '1' || searchValue === 'yes');
                        }
                        return strValue !== searchValue;
                    case 'starts':
                        return strValue.startsWith(searchValue);
                    case 'ends':
                        return strValue.endsWith(searchValue);
                    case 'gt':
                        return parseFloat(itemValue) > parseFloat(value);
                    case 'gte':
                        return parseFloat(itemValue) >= parseFloat(value);
                    case 'lt':
                        return parseFloat(itemValue) < parseFloat(value);
                    case 'lte':
                        return parseFloat(itemValue) <= parseFloat(value);
                    default:
                        return strValue.includes(searchValue);
                }
            },
            
            // Get available fields for current table
            getAvailableFields(tableKey) {
                const schema = DB_SCHEMA[tableKey];
                if (!schema) return [];
                
                return Object.entries(schema.fields).map(([key, def]) => ({
                    key: key,
                    label: def.label || key,
                    type: def.type
                }));
            }
        };

        // ============ MODAL MANAGER ============
        const Modal = {
            open(modalId) {
                document.querySelectorAll('.modal').forEach(m => m.style.display = 'none');
                const modal = document.getElementById(modalId);
                if (modal) modal.style.display = 'flex';
            },
            close(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) modal.style.display = 'none';
            },
            closeAll() {
                document.querySelectorAll('.modal').forEach(m => m.style.display = 'none');
            }
        };

        // ============ INITIALIZATION ============
        document.addEventListener('DOMContentLoaded', async () => {
            generateStats();
            generateTabs();
            generateTableSections();
            setupEventListeners();
            await refreshData();
            switchTab('games');
        });

        // ============ UI GENERATION FROM SCHEMA ============
        function generateStats() {
            const container = document.getElementById('statsContainer');
            let html = '';
            Object.entries(DB_SCHEMA).forEach(([key, schema]) => {
                html += `
                    <div class="stat-card" style="border-left-color: ${schema.color};">
                        <div class="stat-value" id="stat_${key}">-</div>
                        <div class="stat-label">${schema.icon} ${schema.label}</div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        function generateTabs() {
            const container = document.getElementById('tabsContainer');
            let html = '';
            Object.entries(DB_SCHEMA).forEach(([key, schema], index) => {
                html += `<button class="tab-btn ${index === 0 ? 'active' : ''}" data-tab="${key}" onclick="switchTab('${key}')">${schema.icon} ${schema.label}</button>`;
            });
            html += `<button class="tab-btn" data-tab="er-diagram" onclick="switchTab('er-diagram')">üó∫Ô∏è ER Diagram</button>`;
            container.innerHTML = html;
        }

        function generateTableSections() {
            const container = document.getElementById('tablesContainer');
            let html = '';
            Object.entries(DB_SCHEMA).forEach(([key, schema]) => {
                const columns = SchemaManager.getTableColumns(key);
                html += `
                    <div id="${key}Container" class="tab-content">
                        <table id="${key}Table" style="display: none;">
                            <thead>
                                <tr>
                                    ${columns.map(col => {
                                        if (col.key === 'actions') {
                                            return `<th>${col.label}</th>`;
                                        }
                                        return `<th class="sortable" data-column="${col.key}" onclick="sortBy('${col.key}')">
                                            <span class="th-content">${col.label}</span>
                                            <span class="sort-icon" id="sort_${key}_${col.key}"></span>
                                        </th>`;
                                    }).join('')}
                                </tr>
                            </thead>
                            <tbody id="${key}TableBody"></tbody>
                        </table>
                        <div class="empty" id="${key}Empty" style="display: none;">
                            <div class="empty-icon">üìã</div>
                            <div>Nessun record trovato</div>
                        </div>
                        <div class="pagination" id="${key}Pagination" style="display: none;">
                            <button class="pagination-btn" onclick="goToPage(1)" title="Prima pagina">¬´</button>
                            <button class="pagination-btn" onclick="prevPage()" title="Pagina precedente">‚Äπ</button>
                            <span class="pagination-info" id="${key}PageInfo">Pagina 1 di 1</span>
                            <button class="pagination-btn" onclick="nextPage()" title="Pagina successiva">‚Ä∫</button>
                            <button class="pagination-btn" onclick="goToPage(AppState.totalPages)" title="Ultima pagina">¬ª</button>
                            <select class="pagination-select" onchange="changeItemsPerPage(this.value)">
                                <option value="10">10 per pagina</option>
                                <option value="20" selected>20 per pagina</option>
                                <option value="50">50 per pagina</option>
                                <option value="100">100 per pagina</option>
                            </select>
                        </div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        // ============ EVENT LISTENERS ============
        function setupEventListeners() {
            let debounce;
            const searchInput = document.getElementById('searchInput');
            
            searchInput.addEventListener('input', (e) => {
                clearTimeout(debounce);
                debounce = setTimeout(() => {
                    handleSearchInput(e.target.value);
                }, 300);
            });
            
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleSearchInput(e.target.value);
                }
            });

            window.addEventListener('click', (e) => {
                if (e.target.classList.contains('modal')) Modal.closeAll();
            });
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') Modal.closeAll();
            });
        }
        
        function handleSearchInput(value) {
            // Parse query and update filters
            AppState.filters = QueryEngine.parseQuery(value);
            AppState.currentPage = 1;
            updateActiveFiltersUI();
            updateSortIcons();
            updateCurrentSortInfo();
            renderCurrentTable();
        }

        // ============ DATA LOADING ============
        async function refreshData() {
            showLoading(true);
            try {
                const response = await fetch(`${CONFIG.API_BASE}/db-stats?t=${Date.now()}`, { cache: 'no-store' });
                if (!response.ok) throw new Error('Failed to fetch');
                AppState.data = await response.json();
                updateStats();
                renderCurrentTable();
                checkOpenSessions();
            } catch (error) {
                console.error('Error:', error);
                showToast('Errore nel caricamento dati', 'error');
            } finally {
                showLoading(false);
            }
        }

        function updateStats() {
            Object.entries(DB_SCHEMA).forEach(([key, schema]) => {
                const count = AppState.data[schema.dataKey || key]?.length || 0;
                const el = document.getElementById(`stat_${key}`);
                if (el) el.textContent = count;
            });
        }

        // ============ TAB SWITCHING ============
        function switchTab(tabKey) {
            AppState.currentTab = tabKey;
            AppState.currentPage = 1; // Reset pagination on tab change
            AppState.sortColumn = null; // Reset sorting on tab change
            AppState.sortDirection = 'asc';
            
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tabKey);
            });
            
            document.querySelectorAll('.tab-content').forEach(el => {
                el.classList.remove('active');
            });
            
            const container = document.getElementById(`${tabKey}Container`) || document.getElementById(`${tabKey}Container`);
            if (container) container.classList.add('active');
            
            if (tabKey === 'er-diagram') {
                document.getElementById('er-diagramContainer').classList.add('active');
                updateERDiagram();
            } else {
                renderCurrentTable();
            }
        }

        // ============ TABLE RENDERING ============
        function renderCurrentTable() {
            const tableKey = AppState.currentTab;
            if (tableKey === 'er-diagram') return;
            
            const schema = DB_SCHEMA[tableKey];
            if (!schema) return;
            
            let items = AppState.data[schema.dataKey || tableKey] || [];
            
            // Apply filters using QueryEngine
            items = QueryEngine.applyFilters(items, AppState.filters);
            
            // Apply sorting
            items = sortItems(items);
            
            const table = document.getElementById(`${tableKey}Table`);
            const empty = document.getElementById(`${tableKey}Empty`);
            const tbody = document.getElementById(`${tableKey}TableBody`);
            const pagination = document.getElementById(`${tableKey}Pagination`);
            const pageInfo = document.getElementById(`${tableKey}PageInfo`);
            
            if (items.length === 0) {
                table.style.display = 'none';
                empty.style.display = 'flex';
                if (pagination) pagination.style.display = 'none';
                return;
            }
            
            // Calculate pagination
            const totalItems = items.length;
            AppState.totalPages = Math.ceil(totalItems / AppState.itemsPerPage);
            
            // Ensure current page is valid
            if (AppState.currentPage > AppState.totalPages) {
                AppState.currentPage = AppState.totalPages;
            }
            if (AppState.currentPage < 1) {
                AppState.currentPage = 1;
            }
            
            // Get paginated items
            const startIndex = (AppState.currentPage - 1) * AppState.itemsPerPage;
            const endIndex = startIndex + AppState.itemsPerPage;
            const paginatedItems = items.slice(startIndex, endIndex);
            
            table.style.display = 'table';
            empty.style.display = 'none';
            
            const columns = SchemaManager.getTableColumns(tableKey);
            tbody.innerHTML = paginatedItems.map((item, idx) => 
                `<tr>${columns.map(col => renderCell(tableKey, col, item, startIndex + idx)).join('')}</tr>`
            ).join('');
            
            // Update pagination controls
            if (pagination) {
                pagination.style.display = AppState.totalPages > 1 ? 'flex' : 'none';
            }
            if (pageInfo) {
                pageInfo.textContent = `Pagina ${AppState.currentPage} di ${AppState.totalPages} (${totalItems} record)`;
            }
            
            // Update pagination buttons state
            updatePaginationButtons();
        }
        
        function updatePaginationButtons() {
            const tableKey = AppState.currentTab;
            const pagination = document.getElementById(`${tableKey}Pagination`);
            if (!pagination) return;
            
            const buttons = pagination.querySelectorAll('.pagination-btn');
            const isFirstPage = AppState.currentPage === 1;
            const isLastPage = AppState.currentPage === AppState.totalPages;
            
            if (buttons[0]) buttons[0].disabled = isFirstPage; // ¬´
            if (buttons[1]) buttons[1].disabled = isFirstPage; // ‚Äπ
            if (buttons[2]) buttons[2].disabled = isLastPage;  // ‚Ä∫
            if (buttons[3]) buttons[3].disabled = isLastPage;  // ¬ª
        }
        
        function goToPage(page) {
            AppState.currentPage = Math.max(1, Math.min(page, AppState.totalPages));
            renderCurrentTable();
        }
        
        function prevPage() {
            if (AppState.currentPage > 1) {
                AppState.currentPage--;
                renderCurrentTable();
            }
        }
        
        function nextPage() {
            if (AppState.currentPage < AppState.totalPages) {
                AppState.currentPage++;
                renderCurrentTable();
            }
        }
        
        function changeItemsPerPage(value) {
            AppState.itemsPerPage = parseInt(value);
            AppState.currentPage = 1; // Reset to first page
            renderCurrentTable();
        }
        
        function sortBy(column) {
            // Toggle direction if same column, otherwise set to asc
            if (AppState.sortColumn === column) {
                AppState.sortDirection = AppState.sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                AppState.sortColumn = column;
                AppState.sortDirection = 'asc';
            }
            
            AppState.currentPage = 1; // Reset to first page
            renderCurrentTable();
            updateSortIcons();
            updateCurrentSortInfo();
            updateSearchInputFromFilters();
            updateActiveFiltersUI();
        }
        
        function updateSortIcons() {
            const tableKey = AppState.currentTab;
            
            // Clear all sort icons for current table
            document.querySelectorAll(`[id^="sort_${tableKey}_"]`).forEach(icon => {
                icon.textContent = '';
                icon.parentElement.classList.remove('sorted-asc', 'sorted-desc');
            });
            
            // Set active sort icon
            if (AppState.sortColumn) {
                const icon = document.getElementById(`sort_${tableKey}_${AppState.sortColumn}`);
                if (icon) {
                    icon.textContent = AppState.sortDirection === 'asc' ? '‚ñ≤' : '‚ñº';
                    icon.parentElement.classList.add(`sorted-${AppState.sortDirection}`);
                }
            }
        }
        
        function sortItems(items) {
            if (!AppState.sortColumn) return items;
            
            const column = AppState.sortColumn;
            const direction = AppState.sortDirection;
            
            return [...items].sort((a, b) => {
                let valA = a[column];
                let valB = b[column];
                
                // Handle null/undefined
                if (valA === null || valA === undefined) valA = '';
                if (valB === null || valB === undefined) valB = '';
                
                // Numeric comparison
                if (typeof valA === 'number' && typeof valB === 'number') {
                    return direction === 'asc' ? valA - valB : valB - valA;
                }
                
                // Boolean comparison
                if (typeof valA === 'boolean' && typeof valB === 'boolean') {
                    return direction === 'asc' ? (valA === valB ? 0 : valA ? -1 : 1) : (valA === valB ? 0 : valA ? 1 : -1);
                }
                
                // Date comparison
                if (valA instanceof Date || (typeof valA === 'string' && !isNaN(Date.parse(valA)))) {
                    const dateA = new Date(valA);
                    const dateB = new Date(valB);
                    if (!isNaN(dateA) && !isNaN(dateB)) {
                        return direction === 'asc' ? dateA - dateB : dateB - dateA;
                    }
                }
                
                // String comparison
                const strA = String(valA).toLowerCase();
                const strB = String(valB).toLowerCase();
                
                if (direction === 'asc') {
                    return strA.localeCompare(strB, 'it', { numeric: true });
                } else {
                    return strB.localeCompare(strA, 'it', { numeric: true });
                }
            });
        }

        function renderCell(tableKey, column, item, index) {
            const value = item[column.key];
            const schema = DB_SCHEMA[tableKey];
            const pk = schema.primaryKey;
            const pkValue = item[pk];
            
            if (column.key === 'actions') {
                return `
                    <td>
                        <button class="btn-small btn-view" onclick="viewItemById('${tableKey}', '${pkValue}')">View</button>
                        <button class="btn-small btn-edit" onclick="editItemById('${tableKey}', '${pkValue}')">Edit</button>
                        <button class="btn-small btn-delete" onclick="deleteItemById('${tableKey}', '${pkValue}')">Delete</button>
                    </td>
                `;
            }
            
            if (column.render) {
                const rendered = column.render(value, item);
                return `<td>${formatRendered(rendered)}</td>`;
            }
            
            return `<td>${formatValue(value, column.type)}</td>`;
        }

        // Action handlers - find item by primary key
        function getItemByPk(tableKey, pkValue) {
            const schema = DB_SCHEMA[tableKey];
            const items = AppState.data[schema.dataKey || tableKey] || [];
            const pk = schema.primaryKey;
            return items.find(item => String(item[pk]) === String(pkValue));
        }
        
        function viewItemById(tableKey, pkValue) {
            const item = getItemByPk(tableKey, pkValue);
            if (item) showViewModal(tableKey, item);
        }
        
        function editItemById(tableKey, pkValue) {
            const item = getItemByPk(tableKey, pkValue);
            if (item) showEditModal(tableKey, item);
        }
        
        function deleteItemById(tableKey, pkValue) {
            const item = getItemByPk(tableKey, pkValue);
            if (item) showDeleteModal(tableKey, item);
        }

        // Legacy handlers (keep for compatibility)
        function viewItem(tableKey, itemJSON) {
            const item = JSON.parse(decodeURIComponent(itemJSON));
            showViewModal(tableKey, item);
        }
        
        function editItem(tableKey, itemJSON) {
            const item = JSON.parse(decodeURIComponent(itemJSON));
            showEditModal(tableKey, item);
        }
        
        function deleteItem(tableKey, itemJSON) {
            const item = JSON.parse(decodeURIComponent(itemJSON));
            showDeleteModal(tableKey, item);
        }

        function formatRendered(r) {
            if (!r) return '-';
            if (typeof r === 'string') return r;
            switch (r.type) {
                case 'badge': return `<span class="badge" style="background:${r.color};color:#fff;padding:4px 10px;border-radius:12px;font-size:0.75rem;">${r.text}</span>`;
                case 'html': return r.content;
                case 'image': return `<img src="${r.src}" style="${r.style || 'max-width:60px;max-height:45px;border-radius:4px;'}">`;
                case 'text': return `<span style="${r.style || ''}">${r.text}</span>`;
                default: return r.text || '-';
            }
        }

        function formatValue(val, type) {
            if (val === null || val === undefined) return '<span style="color:#999;">-</span>';
            if (type === 'boolean') return val ? '‚úì' : '‚úï';
            if (type === 'date' || type === 'datetime') return new Date(val).toLocaleString('it-IT');
            if (type === 'json') return `<code>${JSON.stringify(val).substring(0, 40)}...</code>`;
            return String(val);
        }

        // ============ VIEW MODAL ============
        function showViewModal(tableKey, item) {
            const schema = DB_SCHEMA[tableKey];
            const modal = document.getElementById('detailModal');
            modal.querySelector('.modal-content').innerHTML = TemplateEngine.renderDetailModal(
                `${schema.icon} ${schema.label}`,
                TemplateEngine.renderDetails(tableKey, item)
            );
            Modal.open('detailModal');
        }

        function closeModal() { Modal.closeAll(); }
        function closeDetailModal() { Modal.close('detailModal'); }
        function closeCRUDModal() { Modal.close('crudModal'); }

        // ============ QUERY BUILDER UI ============
        function toggleQueryBuilder() {
            const panel = document.getElementById('queryBuilderPanel');
            AppState.queryBuilderOpen = !AppState.queryBuilderOpen;
            panel.style.display = AppState.queryBuilderOpen ? 'block' : 'none';
            
            if (AppState.queryBuilderOpen) {
                populateFieldSelector();
                // Close help if open
                document.getElementById('queryHelpPanel').style.display = 'none';
                AppState.queryHelpOpen = false;
            }
        }
        
        function toggleQueryHelp() {
            const panel = document.getElementById('queryHelpPanel');
            AppState.queryHelpOpen = !AppState.queryHelpOpen;
            panel.style.display = AppState.queryHelpOpen ? 'block' : 'none';
            
            if (AppState.queryHelpOpen) {
                // Close builder if open
                document.getElementById('queryBuilderPanel').style.display = 'none';
                AppState.queryBuilderOpen = false;
            }
        }
        
        function populateFieldSelector() {
            const select = document.getElementById('filterField');
            const sortSelect = document.getElementById('sortField');
            const fields = QueryEngine.getAvailableFields(AppState.currentTab);
            
            // Populate filter field dropdown
            select.innerHTML = '<option value="">-- Seleziona campo --</option>';
            fields.forEach(field => {
                select.innerHTML += `<option value="${field.key}" data-type="${field.type}">${field.label} (${field.key})</option>`;
            });
            
            // Populate sort field dropdown (ALL fields from schema, not just visible)
            const schema = DB_SCHEMA[AppState.currentTab];
            if (schema && sortSelect) {
                sortSelect.innerHTML = '<option value="">-- Nessun ordinamento --</option>';
                Object.entries(schema.fields).forEach(([key, def]) => {
                    const label = def.label || key;
                    const selected = AppState.sortColumn === key ? 'selected' : '';
                    sortSelect.innerHTML += `<option value="${key}" ${selected}>${label} (${key})</option>`;
                });
                
                // Set current sort direction
                document.getElementById('sortDirection').value = AppState.sortDirection;
                
                // Update current sort info
                updateCurrentSortInfo();
            }
            
            // Update buttons based on current filters
            updateFilterButtons();
        }
        
        function updateCurrentSortInfo() {
            const infoDiv = document.getElementById('currentSortInfo');
            if (!infoDiv) return;
            
            if (AppState.sortColumn) {
                const schema = DB_SCHEMA[AppState.currentTab];
                const fieldDef = schema?.fields[AppState.sortColumn];
                const fieldLabel = fieldDef?.label || AppState.sortColumn;
                const dirLabel = AppState.sortDirection === 'asc' ? '‚Üë Crescente' : '‚Üì Decrescente';
                
                infoDiv.innerHTML = `Ordinato per: <strong>${fieldLabel}</strong> (${dirLabel})`;
                infoDiv.style.display = 'block';
            } else {
                infoDiv.style.display = 'none';
            }
        }
        
        function applySortFromBuilder() {
            const field = document.getElementById('sortField').value;
            const direction = document.getElementById('sortDirection').value;
            
            if (!field) {
                clearSort();
                return;
            }
            
            AppState.sortColumn = field;
            AppState.sortDirection = direction;
            AppState.currentPage = 1;
            
            renderCurrentTable();
            updateSortIcons();
            updateCurrentSortInfo();
            updateSearchInputFromFilters();
            updateActiveFiltersUI();
            showToast(`Ordinato per ${field} (${direction === 'asc' ? 'crescente' : 'decrescente'})`, 'success');
        }
        
        function clearSort() {
            AppState.sortColumn = null;
            AppState.sortDirection = 'asc';
            
            document.getElementById('sortField').value = '';
            document.getElementById('sortDirection').value = 'asc';
            
            AppState.currentPage = 1;
            renderCurrentTable();
            updateSortIcons();
            updateCurrentSortInfo();
            updateSearchInputFromFilters();
            updateActiveFiltersUI();
        }
        
        function updateFilterButtons() {
            const container = document.getElementById('filterButtons');
            const hasFilters = AppState.filters.filter(f => !f.isOrSeparator).length > 0;
            
            if (hasFilters) {
                // Show AND and OR buttons
                container.innerHTML = `
                    <button class="add-filter-btn" onclick="addFilterFromBuilder()">+ AND</button>
                    <button class="add-filter-or-btn" onclick="addFilterFromBuilder(true)">+ OR</button>
                `;
            } else {
                // Show only Add button
                container.innerHTML = `
                    <button class="add-filter-btn" onclick="addFilterFromBuilder()">+ Aggiungi</button>
                `;
            }
        }
        
        function updateOperatorOptions() {
            const fieldSelect = document.getElementById('filterField');
            const operatorSelect = document.getElementById('filterOperator');
            const selectedOption = fieldSelect.selectedOptions[0];
            const fieldType = selectedOption?.dataset?.type;
            
            // Show all operators, but highlight appropriate ones based on type
            const numericTypes = ['INTEGER', 'FLOAT'];
            const isNumeric = numericTypes.includes(fieldType);
            
            operatorSelect.innerHTML = `
                <option value="contains">contiene</option>
                <option value="equals">uguale a</option>
                <option value="not_equals">diverso da</option>
                <option value="starts">inizia con</option>
                <option value="ends">finisce con</option>
                ${isNumeric || !fieldType ? `
                    <option value="gt">maggiore di (&gt;)</option>
                    <option value="gte">maggiore o uguale (‚â•)</option>
                    <option value="lt">minore di (&lt;)</option>
                    <option value="lte">minore o uguale (‚â§)</option>
                ` : ''}
            `;
        }
        
        function addFilterFromBuilder(asOr = false) {
            const field = document.getElementById('filterField').value;
            const operator = document.getElementById('filterOperator').value;
            const value = document.getElementById('filterValue').value.trim();
            
            if (!field || !value) {
                showToast('Seleziona un campo e inserisci un valore', 'warning');
                return;
            }
            
            const fieldLabel = document.getElementById('filterField').selectedOptions[0].text.split(' (')[0];
            const opLabel = QueryEngine.operatorLabels[operator];
            
            // Add OR separator if requested and there are existing filters
            if (asOr && AppState.filters.length > 0) {
                // Check if last item is not already an OR separator
                const lastFilter = AppState.filters[AppState.filters.length - 1];
                if (!lastFilter.isOrSeparator) {
                    AppState.filters.push({ isOrSeparator: true, display: 'OR' });
                }
            }
            
            AppState.filters.push({
                field: field,
                operator: operator,
                value: value,
                display: `${fieldLabel} ${opLabel} ${value}`
            });
            
            // Clear input
            document.getElementById('filterValue').value = '';
            
            // Update UI
            updateActiveFiltersUI();
            updateSearchInputFromFilters();
            updateFilterButtons();
            AppState.currentPage = 1;
            renderCurrentTable();
        }
        
        function updateActiveFiltersUI() {
            const container = document.getElementById('activeFilters');
            const chipsContainer = document.getElementById('filterChips');
            const sortChip = document.getElementById('sortChip');
            const countContainer = document.getElementById('filterCount');
            const clearAllBtn = document.getElementById('clearAllBtn');
            
            const hasFilters = AppState.filters.length > 0;
            const hasSort = AppState.sortColumn !== null;
            
            if (!hasFilters && !hasSort) {
                container.style.display = 'none';
                return;
            }
            
            container.style.display = 'flex';
            
            // Filter chips
            if (hasFilters) {
                chipsContainer.innerHTML = AppState.filters.map((filter, index) => {
                    if (filter.isOrSeparator) {
                        return `<span class="filter-or-separator">OR</span>`;
                    }
                    return `
                        <span class="filter-chip">
                            <span class="chip-text">${filter.display}</span>
                            <button class="chip-remove" onclick="removeFilter(${index})">‚úï</button>
                        </span>
                    `;
                }).join('');
            } else {
                chipsContainer.innerHTML = '';
            }
            
            // Sort chip
            if (hasSort) {
                const schema = DB_SCHEMA[AppState.currentTab];
                const fieldDef = schema?.fields[AppState.sortColumn];
                const fieldLabel = fieldDef?.label || AppState.sortColumn;
                const dirIcon = AppState.sortDirection === 'asc' ? '‚Üë' : '‚Üì';
                sortChip.innerHTML = `
                    <span class="sort-icon">‚ÜïÔ∏è</span>
                    <span class="sort-text">${fieldLabel} ${dirIcon}</span>
                    <button class="chip-remove" onclick="clearSort()">‚úï</button>
                `;
                sortChip.style.display = 'inline-flex';
            } else {
                sortChip.style.display = 'none';
            }
            
            // Show clear all only if we have filters (sort has its own X)
            clearAllBtn.style.display = hasFilters ? 'inline-block' : 'none';
            
            // Update count
            updateFilterCount();
        }
        
        function updateFilterCount() {
            const countContainer = document.getElementById('filterCount');
            if (!countContainer) return;
            
            const schema = DB_SCHEMA[AppState.currentTab];
            if (!schema) return;
            
            const allItems = AppState.data[schema.dataKey || AppState.currentTab] || [];
            const filteredItems = QueryEngine.applyFilters(allItems, AppState.filters);
            
            const total = allItems.length;
            const found = filteredItems.length;
            
            if (AppState.filters.length > 0) {
                countContainer.innerHTML = `<strong>${found}</strong> di ${total} record`;
                countContainer.style.display = 'inline';
            } else {
                countContainer.style.display = 'none';
            }
        }
        
        function updateSearchInputFromFilters() {
            const input = document.getElementById('searchInput');
            const queryParts = [];
            
            AppState.filters.forEach(f => {
                if (f.isOrSeparator) {
                    queryParts.push('|');
                } else if (f.field === '*') {
                    queryParts.push(f.value);
                } else {
                    const opSymbol = Object.keys(QueryEngine.operators).find(k => QueryEngine.operators[k] === f.operator) || ':';
                    queryParts.push(`${f.field}${opSymbol}${f.value.includes(' ') ? `"${f.value}"` : f.value}`);
                }
            });
            
            // Add sort directive if active
            if (AppState.sortColumn) {
                const sortPart = AppState.sortDirection === 'desc' 
                    ? `sort:-${AppState.sortColumn}` 
                    : `sort:${AppState.sortColumn}`;
                queryParts.push(sortPart);
            }
            
            input.value = queryParts.join(' ');
        }
        
        function removeFilter(index) {
            AppState.filters.splice(index, 1);
            
            // Clean up orphan OR separators
            // Remove leading OR
            while (AppState.filters.length > 0 && AppState.filters[0].isOrSeparator) {
                AppState.filters.shift();
            }
            // Remove trailing OR
            while (AppState.filters.length > 0 && AppState.filters[AppState.filters.length - 1].isOrSeparator) {
                AppState.filters.pop();
            }
            // Remove consecutive ORs
            AppState.filters = AppState.filters.filter((f, i, arr) => {
                if (f.isOrSeparator && i > 0 && arr[i - 1].isOrSeparator) return false;
                return true;
            });
            
            updateActiveFiltersUI();
            updateSearchInputFromFilters();
            updateFilterButtons();
            AppState.currentPage = 1;
            renderCurrentTable();
        }
        
        function clearAllFilters() {
            AppState.filters = [];
            document.getElementById('searchInput').value = '';
            updateActiveFiltersUI();
            updateFilterButtons();
            AppState.currentPage = 1;
            renderCurrentTable();
        }

        // ============ CRUD ============
        function handleCreate() {
            showCreateModal(AppState.currentTab);
        }

        // ============ UTILITIES ============
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'flex' : 'none';
        }

        function showToast(message, type = 'success') {
            if (typeof crudManager !== 'undefined' && crudManager) {
                crudManager.showToast(message, type);
            }
        }

        async function checkOpenSessions() {
            try {
                const response = await fetch(`${CONFIG.API_BASE}/sessions/open`);
                const data = await response.json();
                const btn = document.getElementById('openSessionsBtn');
                if (btn && data.success && data.total_open > 0) {
                    btn.style.display = 'inline-block';
                    btn.textContent = `${data.total_open} Open Sessions`;
                } else if (btn) {
                    btn.style.display = 'none';
                }
            } catch (e) {}
        }

        function showOpenSessions() {
            switchTab('game_sessions');
        }

        function exportJSON() {
            const key = AppState.currentTab;
            const schema = DB_SCHEMA[key];
            if (!schema) return;
            const data = AppState.data[schema.dataKey || key] || [];
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${key}_${new Date().toISOString().slice(0,10)}.json`;
            a.click();
        }

        function exportCSV() {
            const key = AppState.currentTab;
            const schema = DB_SCHEMA[key];
            if (!schema) return;
            const data = AppState.data[schema.dataKey || key] || [];
            if (!data.length) return;
            const headers = Object.keys(data[0]);
            const csv = [headers.join(','), ...data.map(row => 
                headers.map(h => {
                    let v = row[h];
                    if (typeof v === 'object') v = JSON.stringify(v);
                    if (typeof v === 'string' && v.includes(',')) v = `"${v}"`;
                    return v ?? '';
                }).join(',')
            )].join('\n');
            const blob = new Blob([csv], { type: 'text/csv' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${key}_${new Date().toISOString().slice(0,10)}.csv`;
            a.click();
        }

        function logout() {
            document.cookie = 'admin_token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
            window.location.href = '/admin/login';
        }

        // ============ ER DIAGRAM ============
        let erZoom = 1, erPan = { x: 0, y: 0 };

        function updateERDiagram() {
            const svg = document.getElementById('erSvg');
            const showTypes = document.getElementById('showFieldTypes')?.checked ?? true;
            const positions = SchemaManager.getERConfig();

            let content = `
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#666"/>
                    </marker>
                </defs>
                <g transform="translate(${erPan.x}, ${erPan.y}) scale(${erZoom})">
            `;

            // Relationships
            Object.entries(DB_SCHEMA).forEach(([key, schema]) => {
                Object.entries(schema.foreignKeys || {}).forEach(([fk, def]) => {
                    content += TemplateEngine.renderERDiagramRelationship(schema.tableName, fk, def.table, def.field, positions);
                });
            });

            // Tables
            Object.values(positions).forEach(pos => {
                content += TemplateEngine.renderERDiagramTable(pos, showTypes);
            });

            content += '</g>';
            svg.innerHTML = content;
        }

        function resetERDiagram() { erZoom = 1; erPan = { x: 0, y: 0 }; updateERDiagram(); }
        function zoomIn() { erZoom = Math.min(erZoom * 1.2, 3); updateERDiagram(); }
        function zoomOut() { erZoom = Math.max(erZoom / 1.2, 0.3); updateERDiagram(); }
    </script>
</body>
</html>
